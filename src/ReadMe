BogoSort:
    Time Complexity O(n!)
This algorithm is fairly simple, it starts by checking if the list is already sorted,
if it is, its returned. However if it isn't, the array is shuffled so each number has a
new spot in the list, this process is repeated until the array happens to be sorted

The big o is O(n!) because the number of possible combinations in an array of length
n is n!

BogoBogoSort:
    Time Complexity O(n!^n!)
This algorithm is similar to the BogoSort,

Make a copy of the list of numbers.
Sort the first n-1 elements of the copy using bogobogosort.
Check to see if the nth element of the sorted copy is greater than the highest element of the first n-1 elements. If so, the copy is now sorted, else randomise the order of the elements of the copy and go to step 2.
Check to see if the copy is in the same order as the original list.


RoBogoSort:
    Time Complexity O(infinity)
This algorithm is fairly simple in theory, the first thing it does is sort the list
using a different sorting algorithm (I used BogoBogo sort for a laugh), we then create
a new array with the same length as the original and start filling it up with numbers
from 0 to infinity, this new array is compared to the sorted array and is returned
if the arrays are the same, this process is repeated until the list happens to be sorted

similar to "if enough moneys are typing for long enough they'll eventually spit
out the entire works of shakespeare", if enough lists are made for long enough,
eventually it'll spit out the sorted list